<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>我的webpack</title>
  </head>
  <body>
    <h1>我的webpack</h1>
    <div class="box1"></div>
    <div class="box2"></div>
    <div class="box3"></div>
    <div class="box4"></div>
    <div class="box5"></div>
    <span class="iconfont icon-biaoxing"></span>
    <span class="iconfont icon-baocun"></span>
    <span class="iconfont icon-bingtu"></span>
    <span class="iconfont icon-bijiben"></span>
    <span class="iconfont icon-tiaojie"></span>
    <script>
      // //原型继承
      // const Person = {
      //   eyes: 2,
      //   head: 1,
      // };

      // function Women() {}
      // // console.log(Women.prototype);
      // Women.prototype = Person;
      // Women.prototype.constructor = Women;
      // const kate = new Women();

      // console.log(kate.eyes);
      // console.log(Women.prototype);
      // kate.__proto__.eyes = 3;
      // console.log(kate);
      // console.log(kate.eyes);
      // console.log("????", Person);
      // //这样继承有问题，women和man 继承的person共用一片内存(Women.prototype === Man.prototype) 不能各自添加各自独有的属性
      // Person.nose = 1;
      // console.log(Women.prototype);

      // Women.prototype.baby = function () {
      //   console.log("baby");
      // };
      // function Man() {}
      // // console.log(Women.prototype);
      // Man.prototype = Person;
      // Man.prototype.constructor = Man;
      // const kevin = new Man();
      // kevin.baby();
      // kate.baby();

      //使用构造函数 可以实现不同的对象有各自的属性
      function Person() {
        this.eyes = 2;
        this.nose = 1;
      }

      function Women() {}
      Women.prototype = new Person();
      Women.prototype.constructor = Women;
      Women.prototype.baby = function () {
        console.log("baby");
      };
      console.log(Women.prototype);
      const anny = new Women();
      console.log(anny.eyes);
      anny.baby();
      function Man() {}
      Man.prototype = new Person();
      Man.prototype.constructor = Man;
      const max = new Man();
      max.baby(); //没有这个方法
    </script>

    <!-- <script>
      Array.prototype.sum = function () {
        return this.reduce((pre, now) => pre + now);
      };

      Array.prototype.max = function () {
        // let max = this[0];
        // for (let i = 1; i < this.length; i++) {
        //   if (max < this[i]) {
        //     max = this[i];
        //   }
        // }
        return Math.max(...this);
      };
      const arr = [10, 2, 9, 4, 55];
      console.log(arr.sum());
      console.log(arr.max());
    </script> -->
    <!-- <script>
      // 原型prototype
      //公共的属性写到构造函数
      function Star(name, age) {
        this.name = name; //构造函数里的this就是实例对象
        this.age = age;
      }
      //公共的方法写到原型对象上
      Star.prototype.sing = function () {
        console.log("原型里的this", this); //原型对象里的this指向也是实例对象

        console.log("我会唱歌");
      };
      const ldh = new Star("德华", 60);
      const zxy = new Star("学友", 63);
      ldh.sing();
      zxy.sing();
      console.log(ldh.__proto__ === Star.prototype); //对象原型__proto__和[[Prototype]]相同 指向该构造函数的原型对象  只读

      // console.log(ldh.sing === zxy.sing);
      // console.log(Star.prototype);
      console.log(Star.prototype.constructor === Star); //原型对象里的constructor指回了构造函数
    </script> -->
    <!-- <script>
      // let a = 0;
      // function logp() {
      //   console.log(`被调用${++a}次`);
      // }
      //闭包可以私有化变量 防止外部修改变量
      // function logCountClosure() {
      //   let i = 0;
      //   return function fn() {
      //     console.log(`被调用${++i}次`);
      //   };
      // }
      // const logC = logCountClosure();

      //this指向window
      // console.log(this);

      //普通函数指向window
      function fn() {
        console.log(this); //this指向函数的调用者 window.fn()
      }
      fn();

      //对象中的this
      const obj = {
        name: "sdfa",
        say: function () {
          console.log(this);
        },
      };

      obj.say();

      //箭头函数本身没有this 他的this会沿着作用域链的上一层寻找this
      const ffn = () => {
        console.log(this);
      };
      ffn();
    </script> -->
    <!-- 手动引入改为使用插件自动引入 -->
    <!-- <script src="../dist/static/js/main.js"></script> -->
  </body>
</html>
