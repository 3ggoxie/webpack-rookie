<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>我的webpack</title>
  </head>
  <body>
    <h1>我的webpack</h1>
    <div class="box1"></div>
    <div class="box2"></div>
    <div class="box3"></div>
    <div class="box4"></div>
    <div class="box5"></div>
    <span class="iconfont icon-biaoxing"></span>
    <span class="iconfont icon-baocun"></span>
    <span class="iconfont icon-bingtu"></span>
    <span class="iconfont icon-bijiben"></span>
    <span class="iconfont icon-tiaojie"></span>
    <script>
      // 原型prototype
      //公共的属性写到构造函数
      function Star(name, age) {
        this.name = name; //构造函数里的this就是实例对象
        this.age = age;
      }
      //公共的方法写到原型对象上
      Star.prototype.sing = function () {
        console.log("原型里的this", this); //原型对象里的this指向也是实例对象

        console.log("我会唱歌");
      };
      const ldh = new Star("德华", 60);
      const zxy = new Star("学友", 63);
      ldh.sing();
      zxy.sing();

      console.log(ldh.sing === zxy.sing);
      console.log(Star.prototype);
    </script>
    <!-- <script>
      // let a = 0;
      // function logp() {
      //   console.log(`被调用${++a}次`);
      // }
      //闭包可以私有化变量 防止外部修改变量
      // function logCountClosure() {
      //   let i = 0;
      //   return function fn() {
      //     console.log(`被调用${++i}次`);
      //   };
      // }
      // const logC = logCountClosure();

      //this指向window
      // console.log(this);

      //普通函数指向window
      function fn() {
        console.log(this); //this指向函数的调用者 window.fn()
      }
      fn();

      //对象中的this
      const obj = {
        name: "sdfa",
        say: function () {
          console.log(this);
        },
      };

      obj.say();

      //箭头函数本身没有this 他的this会沿着作用域链的上一层寻找this
      const ffn = () => {
        console.log(this);
      };
      ffn();
    </script> -->
    <!-- 手动引入改为使用插件自动引入 -->
    <!-- <script src="../dist/static/js/main.js"></script> -->
  </body>
</html>
