<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>我的webpack</title>
  </head>
  <body>
    <div
      class="zone"
      style="
        background-color: wheat;
        width: 100px;
        height: 100px;
        text-align: center;
      "
    >
      1
    </div>
    <!-- <button id="btn">禁用两秒</button> -->
    <!-- <h1>我的webpack</h1>
    <div class="box1"></div>
    <div class="box2"></div>
    <div class="box3"></div>
    <div class="box4"></div>
    <div class="box5"></div>
    <span class="iconfont icon-biaoxing"></span>
    <span class="iconfont icon-baocun"></span>
    <span class="iconfont icon-bingtu"></span>
    <span class="iconfont icon-bijiben"></span>
    <span class="iconfont icon-tiaojie"></span> -->
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <script>
      //节流throttle
      // //lodash实现
      // const div = document.querySelector(".zone");
      // let i = 1;
      // function move() {
      //   console.log("sss");

      //   div.innerHTML = i++;
      // }

      // div.addEventListener("mousemove", _.throttle(move, 5000));
      //手写节流;
      const div = document.querySelector(".zone");
      let i = 1;
      function move() {
        div.innerHTML = i++;
      }
      function throttle(fn, wait) {
        let timer = null;

        return function (...args) {
          const context = this;
          if (!timer) {
            fn.apply(context, args);
            timer = setTimeout(() => {
              // clearTimeout(timer);
              //在 setTimeout中无法清除定时器，因为定时器还在运作，所以应该用timer=null
              timer = null;
            }, wait);
          }
        };
      }
      div.addEventListener("mousemove", throttle(move, 5000));
    </script>
    <!-- <script>
      //防抖debounce
      //lodash实现
      // const div = document.querySelector(".zone");
      // let i = 1;
      // function move() {
      //   console.log("sss");

      //   div.innerHTML = i++;
      // }

      // div.addEventListener("mousemove", _.debounce(move, 500));
      //手写防抖
      const div = document.querySelector(".zone");
      let i = 1;
      function move() {
        div.innerHTML = i++;
      }
      function deBounce(fn, wait) {
        let timer = null; // 通过闭包保存定时器ID

        return function (...args) {
          const context = this;
          if (timer) clearTimeout(timer);
          timer = setTimeout(() => {
            fn.apply(context, args);
            console.log(...args);
          }, wait);
        };
      }
      div.addEventListener("mousemove", deBounce(move, 5000));
    </script> -->
    <!-- <script>
      const obj = {
        name: "ssg",
      };
      // function fm() {
      //   console.log(this);
      // }
      // // fm.call(obj);
      // // fm.apply(obj);
      // const fn = fm.bind(obj);
      // fn();
      // document.getElementById("btn").addEventListener("click", function () {
      //   this.disabled = true;
      //   setTimeout(() => {
      //     this.disabled = false;
      //     console.log(this);
      //   }, 2000);
      // });
      //箭头函数不能通过以上三种方法改变this指向，永远向上寻找父元素的this指向
      const fn = () => {
        console.log(this);
      };
      fn.bind(obj)();
    </script> -->

    <!-- <script>
      //异常处理
      function fn(a, b) {
        debugger; //打断点
        if (!a || !b) {
          // throw "缺少参数";
          throw new Error("缺少参数");
        }
        return a + b;
      }
      console.log(fn());
    </script> -->
    <!-- <script>
      //深拷贝
      //JSON.stringify()
      const obj = {
        uname: "ssg",
        age: 18,
        family: {
          mom: "cdf",
        },
        hobby: ["唱", "跳", "rap"],
      };

      let o = JSON.parse(JSON.stringify(obj));
      console.log(o);
      o.age = 20;
      o.hobby[0] = "篮球";
      o.family.mom = "ccc";
      console.log(obj);
      console.log(Array instanceof Object);
      // //loadash
      // const obj = {
      //   uname: "ssg",
      //   age: 18,
      //   family: {
      //     mom: "cdf",
      //   },
      //   hobby: ["唱", "跳", "rap"],
      // };

      // let o = _.cloneDeep(obj);
      // console.log(o);
      // o.age = 20;
      // o.hobby[0] = "篮球";
      // o.family.mom = "ccc";
      // console.log(obj);
      // console.log(Array instanceof Object);

      // //递归实现 简易版
      // const obj = {
      //   uname: "ssg",
      //   age: 18,
      //   family: {
      //     mom: "cdf",
      //   },
      //   hobby: ["唱", "跳", "rap"],
      // };

      // let o = {};
      // function deepCopy(newObj, oldObj) {
      //   for (let key in oldObj) {
      //     if (oldObj[key] instanceof Array) {
      //       newObj[key] = [];
      //       deepCopy(newObj[key], oldObj[key]);
      //     } else if (oldObj[key] instanceof Object) {
      //       newObj[key] = {};
      //       deepCopy(newObj[key], oldObj[key]);
      //     } else {
      //       newObj[key] = oldObj[key];
      //     }
      //   }
      // }
      // deepCopy(o, obj);
      // console.log(o);
      // o.age = 20;
      // o.hobby[0] = "篮球";
      // o.family.mom = "ccc";
      // console.log(obj);
      // console.log(Array instanceof Object);

      // let a = 2;
      // let b = a;
      // b = 3;
      // console.log(a);
      // console.log(b);

      // const obj = {
      //   uname: "ssg",
      //   age: 18,
      //   family: {
      //     mom: "cdf",
      //   },
      // };
      // const o = obj;
      // console.log(o);
      // o.age = 24;
      // console.log(o);
      // console.log(obj);
      //浅拷贝
      //空对象+展开运算符
      // const o = { ...obj };
      // console.log(o);
      // o.age = 24;
      // console.log(o);
      // console.log(obj);
      //assign方法
      // const o = {};
      // Object.assign(o, obj);
      // console.log(o);
      // o.age = 24;
      // o.family.mom = "ccc";
      // console.log(o);
      // console.log(obj);
    </script> -->
    <!-- <script>
      // //原型继承
      // const Person = {
      //   eyes: 2,
      //   head: 1,
      // };

      // function Women() {}
      // // console.log(Women.prototype);
      // Women.prototype = Person;
      // Women.prototype.constructor = Women;
      // const kate = new Women();

      // console.log(kate.eyes);
      // console.log(Women.prototype);
      // kate.__proto__.eyes = 3;
      // console.log(kate);
      // console.log(kate.eyes);
      // console.log("????", Person);
      // //这样继承有问题，women和man 继承的person共用一片内存(Women.prototype === Man.prototype) 不能各自添加各自独有的属性
      // Person.nose = 1;
      // console.log(Women.prototype);

      // Women.prototype.baby = function () {
      //   console.log("baby");
      // };
      // function Man() {}
      // // console.log(Women.prototype);
      // Man.prototype = Person;
      // Man.prototype.constructor = Man;
      // const kevin = new Man();
      // kevin.baby();
      // kate.baby();

      // //使用构造函数 可以实现不同的对象有各自的属性
      // function Person() {
      //   this.eyes = 2;
      //   this.nose = 1;
      // }

      // function Women() {}
      // Women.prototype = new Person();
      // Women.prototype.constructor = Women;
      // Women.prototype.baby = function () {
      //   console.log("baby");
      // };
      // console.log(Women.prototype);
      // const anny = new Women();
      // console.log(anny.eyes);
      // anny.baby();
      // function Man() {}
      // Man.prototype = new Person();
      // Man.prototype.constructor = Man;
      // const max = new Man();
      // // max.baby(); //没有这个方法
      // console.log(anny instanceof Women);
      // console.log(anny instanceof Person);
      // console.log(anny instanceof Object);
      // console.log(anny instanceof Array);

    </script> -->

    <!-- <script>
      Array.prototype.sum = function () {
        return this.reduce((pre, now) => pre + now);
      };

      Array.prototype.max = function () {
        // let max = this[0];
        // for (let i = 1; i < this.length; i++) {
        //   if (max < this[i]) {
        //     max = this[i];
        //   }
        // }
        return Math.max(...this);
      };
      const arr = [10, 2, 9, 4, 55];
      console.log(arr.sum());
      console.log(arr.max());
    </script> -->
    <!-- <script>
      // 原型prototype
      //公共的属性写到构造函数
      function Star(name, age) {
        this.name = name; //构造函数里的this就是实例对象
        this.age = age;
      }
      //公共的方法写到原型对象上
      Star.prototype.sing = function () {
        console.log("原型里的this", this); //原型对象里的this指向也是实例对象

        console.log("我会唱歌");
      };
      const ldh = new Star("德华", 60);
      const zxy = new Star("学友", 63);
      ldh.sing();
      zxy.sing();
      console.log(ldh.__proto__ === Star.prototype); //对象原型__proto__和[[Prototype]]相同 指向该构造函数的原型对象  只读

      // console.log(ldh.sing === zxy.sing);
      // console.log(Star.prototype);
      console.log(Star.prototype.constructor === Star); //原型对象里的constructor指回了构造函数
    </script> -->
    <!-- <script>
      // let a = 0;
      // function logp() {
      //   console.log(`被调用${++a}次`);
      // }
      //闭包可以私有化变量 防止外部修改变量
      // function logCountClosure() {
      //   let i = 0;
      //   return function fn() {
      //     console.log(`被调用${++i}次`);
      //   };
      // }
      // const logC = logCountClosure();

      //this指向window
      // console.log(this);

      //普通函数指向window
      function fn() {
        console.log(this); //this指向函数的调用者 window.fn()
      }
      fn();

      //对象中的this
      const obj = {
        name: "sdfa",
        say: function () {
          console.log(this);
        },
      };

      obj.say();

      //箭头函数本身没有this 他的this会沿着作用域链的上一层寻找this
      const ffn = () => {
        console.log(this);
      };
      ffn();
    </script> -->
    <!-- 手动引入改为使用插件自动引入 -->
    <!-- <script src="../dist/static/js/main.js"></script> -->
  </body>
</html>
